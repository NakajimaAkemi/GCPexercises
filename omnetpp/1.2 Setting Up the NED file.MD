# Set up

In this markdown we will see how to use setup the NED file.

## Code outline
This a base for our Network .
```NED
//import org.omnetpp.queueing.Queue;
//import org.omnetpp.queueing.Sink;
//import org.omnetpp.queueing.Source;

network ourNetwork {
    parameters:
        
    submodules:
        
    connections:
        
}
```


## submodules and parameters
The submodule and parameters fields are defined together, as we define the elements of our networks and their behaviour, there are multiple kinds of submodule:
 - Source
 - Queue
 - Sink
 - Router
 - Delay
 - Classifier
 - Fork
 - Merge
### Submodule declaration
The declaration has the `name:Class` format such as the example below.
```NED  
    submodules:
	srv2: Queue;
	sink1: Sink;
```
### Source, Queue and Sink modules
These modules are employed together in most cases.
```NED
import org.omnetpp.queueing.Queue;
import org.omnetpp.queueing.Sink;
import org.omnetpp.queueing.Source;
....
    parameters:
	//double rho=lambda/rho;
        double rho=default(...);
	//double mu=lambda/rho;
        double mu=default(...);
	//double lambda =default(...)
        double lambda = mu*rho;
	//double K=default(-1) //infinite capacity
        src.interArrivalTime = 1s * exponential(1/lambda);
        //srv.capacity = K;
        srv.serviceTime = 1s * exponential(1/mu);
    submodules:
        src: Source;
        srv: Queue;
        sink: Sink;
...
```
#### Log normal service time
The queue service time can also follow a lognormal distribution, given a mu and coefficient of variance, which serve to calculate the mean and stdev for the lognormal function.

```NED
....
    parameters:
	double mu=default(10.0);
	double cv=default(1.0);
	srv.serviceTime = 1.0s*lognormal(log(1.0/(mu*sqrt(1+cv^2))), sqrt(log(1+cv^2)));
```
#### Source Jobtype definition
We can define the Jobtype of our source, which allows us to handle them afterwards, the Jobtype only allow 2 Jobtype high=1 and low=0.
```NED
....
    parameters:
	src_high.jobType = 1;
	src_low.jobType = 0;
	srv.serviceTime = 1.0s*lognormal(log(1.0/(mu*sqrt(1+cv^2))), sqrt(log(1+cv^2)));
```

#### Classifier and Job type handling
The `Classifier submodule` analyzes the Job type and priority and routes the message depending on their value, we define a dispatchField propriety which can be `type` or `priority`, if the `priority` or `type` is set to the value `i` the message will be routed to the `output[i]` the other outputs are sent to the `rest` gate.

```NED
import org.omnetpp.queueing.Source;
import org.omnetpp.queueing.Classifier;
...
	parameters:
		src_high.jobType = 1;
		src_low.jobType = 0;
		classifier.dispatcherField = 1;
	submodules:
		src_high.out --> srv_high.in++;
		src_low.out --> srv_low.in++;
		srv_high.out --> classifier.in++;
		srv_low.out --> classifier.in++;
		//classifier outputting 
		classifier.out++ --> sink_high.in++;
		classifier.rest --> sink_low.in++;
```
### Delay
This submodule has the purpose to simulate a delay between nodes.
```NED
import org.omnetpp.queueing.Delay;
...
	parameters:
		double delta=default(0.1);
		delay.delay=1.0s*truncnormal(delta, 0.1*delta);
		//delay.delay=0s;
	submodules:
		delay: Delay;
		sink: Sink;
```

### Router
Sends to different outputs depending on the algorithm. 
```NED
import org.omnetpp.queueing.Router;
...
	parameters:
		...
		r.routingAlgorithm = "random";
		//r.routingAlgorithm = "roundRobin";
		//r.routingAlgorithm = "shortestQueue";
		//r.routingAlgorithm = "minDelay";
	submodules:
		r: Router;
	connections:
		src1.out --> r.in++;
		r.out++ --> srv1.in++;
		src2.out --> r.in++;
		r.out++ --> srv2.in++;
...
```


### Forks and merge
These submodules split and join jobs.

## Parameters
We define here our parameters and measurements for our analysis.
```NED
import org.omnetpp.queueing.;
import org.omnetpp.queueing.Join;

int K=default(10);
        double rho=default(0.8);
        double mu=default(10);
        double lambda = mu*rho;
        src.interArrivalTime = 1s * exponential(1/lambda);
        srv.capacity = K;
        srv.serviceTime = 1s * exponential(1/mu);

src: Source;
        srv: Queue;
        sink: Sink;

src.out --> srv.in++;
        srv.out --> sink.in++;





network MM1_LB1
{
	parameters:
		double mu1=default(5);
		double mu2=default(5);
		double lambda1 = default(4.5);
		double lambda2 = default(2);
		src1.interArrivalTime = exponential(1s/lambda1);
		src2.interArrivalTime = exponential(1s/lambda2);
		srv1.serviceTime = 1s * exponential(1/mu1);
		srv2.serviceTime = 1s * exponential(1/mu2);
	submodules:
		src1: Source;
		src2: Source;
		// disable router by commenting out this line
		r: Router;
		srv1: Queue;
		srv2: Queue;
		sink1: Sink;
		sink2: Sink;
	connections:
		// to disable router:
		// src1.out --> srv1.in++
		src1.out --> r.in++;
		r.out++ --> srv1.in++;
		// to disable router:
		// src2.out --> srv2.in++
		src2.out --> r.in++;
		r.out++ --> srv2.in++;
		srv1.out --> sink1.in++;
		srv2.out --> sink2.in++;
}
```


## Connections
The `connections` section is where we define the topology of our network with the submodules we defined before, some of submodules can allow multiple inputs/outputs we need to put `++` right on that input/output.
```NED
	connections:
		src1.out --> srv1.in++
		r.out++ --> srv1.in++;
```

### Defining an array of components and connecting them
We can declare an array of components, define their parameters and connect them by using the for cycle, allowing us to save some time.
```NED
	parameters:
		int N=default(5);
		src[*].interArrivalTime = exponential(1s/lambda);
		srv[*].serviceTime = 1.0s*exponential(1.0/mu);
		delay[*].delay=0s;
	submodules:
		src[N]: Source;
		srv[N]: Queue;
		delay[N]: Delay;
		sink: Sink;
	connections:
	    for i=0..N-1 {
    		src[i].out --> delay[i].in++;
    		delay[i].out --> srv[i].in++;
    		srv[i].out --> sink.in++;
```

